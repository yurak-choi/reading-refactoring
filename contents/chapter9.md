**9.1 변수 쪼개기**
- 루프 변수, 수집 변수가 아닌 참조 목적의 변수에는 값을 단 한 번만 대입해야한다. 대입이 두 번 이상 이뤄진다면 여러 가지 역할을 수행한다는 신호다.

**9.2 필드 이름 바꾸기**
- 데이터 테이블 없이 흐름도만 보여줘서는 나는 여전히 혼란스러울 것이다. 하지만 데이터 테이블을 보여준다면 흐름도는 웬만해선 필요조차 없을 것이다. 테이블만으로 명확하기 때문이다.
- 그래서 이름을 잘지어야 한다.

**9.3 파생 변수를 질의 함수로 바꾸기**
- 가변 데이터는 한 쪽 코드에서 수정한 값이 연쇄 효과를 일으켜 다른 쪽 코드에 원인을 찾기 어려운 문제를 야기한다.
- 가변 데이터의 유효 범위를 가능한 한 좁혀야 한다.

**9.4 참조를 값으로 바꾸기**
- 값 객체는 대체로 자유롭게 활용하기 좋은데, 특히 불변이기 때문이다.
- 불변 데이터 값은 외부로 건네줘도 나몰래 그 값이 바뀌어서 내부에 영향을 줄까 염려하지 않아도 된다.

**9.5 값을 참조로 바꾸기**
- 하나의 데이터 구조 안에 논리적으로 똑같은 제3의 데이터 구조를 참조하는 레코드가 여러 개 있을 때가 있다.
- 데이터를 갱신할 일이 없다면 값이든 참조든 상관없다.
- 갱신을 해야 하면 모든 복제본을 찾아서 갱신해줘야한다.(값으로 다룰 경우)
- 참조로 다룰 경우 객체를 한 번만 만들고, 객체가 필요한 곳에서는 이 저장소로부터 얻어 쓰는 방식이 좋다.
```
let _repositoryData;

export function initialize() {
  _repositoryData = {};
  _repositoryData.customers = new Map();
}

export function registerCustomer(id) {
  If (!_repositoryData.customers.has(id))
    _repositoryData.customers.set(id, new Customer(id));
  return findCustomer(id);
}

export function findCustomer(id) {
  return _repositoryData.customers.get(id);
}
```

**9.6 매직 리터럴 바꾸기**
- 일반적인 리터럴 값
- 의미를 알고 있다고 해도 코드 자체가 뜻을 분명하게 드러내는 게 좋다.
- const ONE = 1 같은 선언은 의미가 없다.
