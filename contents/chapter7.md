## 인상 깊었던 내용

**7.1 레코드 캡슐화하기**
- class로 캡슐화하면 변수/메서드명을 변경한다던가, 로직을 수정할 때 새로운 메서드를 추가해서 기존 코드를 모두 변경할 때까지 점진적으로 수정할 수 있어서 좋을 것 같다.
  - 클래스로 캡슐화하지 않아도 할 수 있지만 코드가 흩어져 있어서 시간이 지나면 파악하기 힘들다. 클래스로 묶여있으면 파악하기 쉬울 것 같다.
- 하지만 결국 객체… 리팩터링을 위해 객체를 만들면서 연관이 있는 객체를 어떻게 설계하면 좋을지 궁금하다.

**7.2 컬렉션 캡슐화하기**
- 원본 컬렉션을 반환하지 않도록 하는 것은 동의한다.
- 운영에 배포하지는 않았지만 개발 중에 원본을 수정하는 상황이 가끔씩 발생한다.
- class로 구조화 해두면 무의식적으로 원본 컬렉션을 반환하는 상황을 방지해줄 것 같다.
  - getter를 만들면서 '아 이거 컬렉션이지?' 하지 않을까... 물론 기계처럼 원본을 반환하는 getter를 만들 수도 있다~

**7.3 기본형을 객체로 바꾸기**
- 좋은 생각인 것은 같다.
- 아래처럼 util 함수 형태와 클래스 형태 중에 어떤 형식이 괜찮아 보이는지 이야기 해보면 좋을 것 같다.
```
// util 함수
export const addDashInContact = (contact) => {
  return contact.replace(/(\d{3})(\d{3,4})(\d{4})/, '$1-$2-$3')
}

// 클래스
class TelNumber {
  get phoneNumber() {
    return this.number.replace(/(\d{3})(\d{3,4})(\d{4})/, '$1-$2-$3')
  }
}
```

**7.6 클래스 인라인하기**
- 제 역할을 못 하는 클래스를 인라인 한다.
    - 클래스간 관련이 없어도 합치는 것일까?? 그러면 나중에 또 나눌거 같은데..

**7.7 위임 숨기기**
**7.8 중재자 제거하기**
- 책을 읽다보니 어쩔땐 합치고 어쩔땐 나누는 것의 반복이다.
  - 결국은 내가 짜고 싶은대로 짜라? ㅎㅎ
- 리팩터링은 결코 미안하다고 말하지 않는다. 즉시 고칠 뿐이다.
