**3.1 기이한 이름**
- 마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어 있을 가능성이 높다.
    - 앞으로 코드 짤 때 이름이 안떠오르면 함수를 더 쪼갤 수 있을지 찾아봐야겠다

**3.2 중복 코드**
- utils에 넣기는 애매하고 소수의 컴포넌트에서만 코드가 중복되면 다른 사람들은 그 코드를 어디에 저장해놓는지 궁금하다.

**3.3 긴함수**
- 핵심은 함수의 길이가 아닌, 함수의 목적과 구현 코드의 괴리가 얼마나 큰가다. 즉, 무엇을 하는지를 코드가 잘 설명해주지 못할수록 함수로 만드는 게 유리하다.

**3.7 뒤엉킨 변경**
- 코드를 수정할때는 한 군데를 찾아서 수정할 수 있어야 한다. 데이터베이스가 추가될 때마다 함수 세 개를 바꿔야 한다면 뒤엉킨 변경이 발생했다는 뜻이다.

**3.8 산탄총 수술**
- 뒤엉킨 변경의 반대, 뒤엉킨 변경은 코드를 분리하고 산탄총 수술은 코드를 모은다.

**3.9 기능 편애**
- 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용할 일이 더 많을 때 풍기는 냄새다.
- 내용은 이해가는데 어떤 상황인지 잘 모르겠다.

**3.10 데이터 뭉치**
- 어떤 상황인지 잘 모르겠다.

**3.11 기본형 집착**
- 화폐, 물리량 등을 기본형으로 처리하는 경우
- 좀 귀찮긴 하지만 좋은 생각인 것 같다.
- 클래스로 선언해서 변수는 캡슐화하고 게터 함수 안에서 변환해서 사용하면 통일해서 사용하기 좋을 것 같다.
- 린다에서 혈액 검사 등을 노출할 때 정상 범위 체크하는 로직이 있었는데 클래스 안에서 함수로 선언하면 코드가 분리되어 좋았을듯..??

**3.12 반복되는 switch문**
- 중복된 조건부 로직을 제거하자

**3.13 반복문**
- 파이프라인으로 바꾸기

**3.14 성의 없는 요소**
- 의미없는 함수, 클래스 등을 고이 보내드리자

**3.17 메시지 체인**
- 다른 객체를 요청하는 작업이 연쇄적으로 이어지는 코드
    - 게터 함수가 꼬리에 꼬리를 물고 이어지거나
    - 임시 변수들이 줄줄이 나열되는 코드

**3.18 중개자**
- 클래스가 제공하는 메서드 중 절반이 다른 클래스에 구현을 위임하고 있는 상황

**3.19 내부자 거래**
- 모듈 사이의 데이터 거래가 많아 결합도가 높아진 상황
- 일이 돌아가게 하려면 거래가 이뤄질 수 밖에 없지만, 그 양을 최소로 줄이고 모두 투명하게 처리해야 한다.


**3.20 거대한 클래스**
- 한 클래스가 너무 많은 일을 하려다 보면 필드 수가 상당히 늘어난다.
- 클래스에 필드가 너무 많으면 중복 코드가 생기기 쉽다.
- 마찬가지로 코드량이 너무 많은 클래스도 중복 코드가 생기기 쉽다.

**3.21 서로 다른 인터페이스의 대안 클래스들**
- ???

**3.22 데이터 클래스**
- 데이터 필드와 게터/세터 메서드로만 구성된 클래스
- Public 필드가 있다면 캡슐화로 숨기자
- 필요한 동작이 엉뚱한 곳에 정의돼 있다는 신호일 수 있다.

**3.23 상속 포기**
- ???

**3.24 주석**
- 주석은 악취가 아닌 향기다. 문제는 주석을 탈취제처럼 사용하는데 있다.
- 주석을 남겨야겠다는 생각이 들면, 가장 먼저 주석이 필요없는 코드로 리팩터링해본다.
